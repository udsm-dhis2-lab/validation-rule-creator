{"ast":null,"code":"import { useEffect, useState } from 'react';\n/*\n * The initial call is irrelevant as there has been\n * no resize yet that we want to react to\n * So we start with -1 with will returned as 0 by this hook\n *\n * @param {Element} element\n * @returns {number}\n */\n\nexport const useResizeCounter = element => {\n  const [counter, setCounter] = useState(-1);\n  useEffect(() => {\n    // using an internal counter as using the one from `useState`\n    // would cause an infinite loop as this `useEffect` would\n    // both depend on that value as well as change it every time\n    // it's executed as the callback passed to `ResizeObserver`\n    // will be executed on construction\n    let internalCounter = counter;\n\n    if (element) {\n      const observer = new ResizeObserver(() => {\n        ++internalCounter;\n        setCounter(internalCounter);\n      });\n      observer.observe(element);\n      return () => observer.disconnect();\n    }\n  }, [element, setCounter]);\n  return counter < 1 ? 0 : counter;\n};","map":{"version":3,"sources":["/Users/rajabu/.config/yarn/global/node_modules/@dhis2/ui/node_modules/@dhis2/ui-widgets/build/es/Transfer/useResizeCounter.js"],"names":["useEffect","useState","useResizeCounter","element","counter","setCounter","internalCounter","observer","ResizeObserver","observe","disconnect"],"mappings":"AAAA,SAASA,SAAT,EAAoBC,QAApB,QAAoC,OAApC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,OAAO,MAAMC,gBAAgB,GAAGC,OAAO,IAAI;AACzC,QAAM,CAACC,OAAD,EAAUC,UAAV,IAAwBJ,QAAQ,CAAC,CAAC,CAAF,CAAtC;AACAD,EAAAA,SAAS,CAAC,MAAM;AACd;AACA;AACA;AACA;AACA;AACA,QAAIM,eAAe,GAAGF,OAAtB;;AAEA,QAAID,OAAJ,EAAa;AACX,YAAMI,QAAQ,GAAG,IAAIC,cAAJ,CAAmB,MAAM;AACxC,UAAEF,eAAF;AACAD,QAAAA,UAAU,CAACC,eAAD,CAAV;AACD,OAHgB,CAAjB;AAIAC,MAAAA,QAAQ,CAACE,OAAT,CAAiBN,OAAjB;AACA,aAAO,MAAMI,QAAQ,CAACG,UAAT,EAAb;AACD;AACF,GAhBQ,EAgBN,CAACP,OAAD,EAAUE,UAAV,CAhBM,CAAT;AAiBA,SAAOD,OAAO,GAAG,CAAV,GAAc,CAAd,GAAkBA,OAAzB;AACD,CApBM","sourcesContent":["import { useEffect, useState } from 'react';\n/*\n * The initial call is irrelevant as there has been\n * no resize yet that we want to react to\n * So we start with -1 with will returned as 0 by this hook\n *\n * @param {Element} element\n * @returns {number}\n */\n\nexport const useResizeCounter = element => {\n  const [counter, setCounter] = useState(-1);\n  useEffect(() => {\n    // using an internal counter as using the one from `useState`\n    // would cause an infinite loop as this `useEffect` would\n    // both depend on that value as well as change it every time\n    // it's executed as the callback passed to `ResizeObserver`\n    // will be executed on construction\n    let internalCounter = counter;\n\n    if (element) {\n      const observer = new ResizeObserver(() => {\n        ++internalCounter;\n        setCounter(internalCounter);\n      });\n      observer.observe(element);\n      return () => observer.disconnect();\n    }\n  }, [element, setCounter]);\n  return counter < 1 ? 0 : counter;\n};"]},"metadata":{},"sourceType":"module"}