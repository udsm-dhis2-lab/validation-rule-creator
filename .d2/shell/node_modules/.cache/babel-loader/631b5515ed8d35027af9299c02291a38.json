{"ast":null,"code":"import { FetchError } from '../../engine';\nexport const parseContentType = contentType => contentType ? contentType.split(';')[0].trim().toLowerCase() : '';\nexport const parseStatus = async response => {\n  const accessError = response.status === 401 || response.status === 403 || response.status === 409;\n\n  if (accessError) {\n    let message;\n    let details = {};\n\n    try {\n      details = await response.json();\n      message = details.message;\n    } catch (e) {// Do nothing\n    } // Set a message in case of invalid json, or json without 'message' property\n\n\n    if (!message) {\n      message = response.status === 401 ? 'Unauthorized' : 'Forbidden';\n    }\n\n    throw new FetchError({\n      type: 'access',\n      message,\n      details\n    });\n  }\n\n  if (response.status < 200 || response.status >= 400) {\n    const message = \"An unknown error occurred - \".concat(response.statusText, \" (\").concat(response.status, \")\");\n    let details = {};\n\n    try {\n      details = await response.json();\n    } catch (e) {// We can leave details as is if parsing fails\n    }\n\n    throw new FetchError({\n      type: 'unknown',\n      message,\n      details\n    });\n  }\n\n  return response;\n};\nexport function fetchData(url, options = {}) {\n  return fetch(url, { ...options,\n    credentials: 'include',\n    headers: {\n      'X-Requested-With': 'XMLHttpRequest',\n      Accept: 'application/json',\n      ...options.headers\n    }\n  }).catch(err => {\n    throw new FetchError({\n      type: 'network',\n      message: 'An unknown network error occurred',\n      details: err\n    });\n  }).then(parseStatus).then(async response => {\n    const contentType = parseContentType(response.headers.get('Content-Type')); // 'application/json'\n\n    if (contentType === 'application/json') {\n      return await response.json(); // Will throw if invalid JSON!\n    } // 'text/*'\n\n\n    if (/^text\\/[a-z0-9.-]+$/.test(contentType)) {\n      return await response.text();\n    }\n\n    return await response.blob();\n  });\n}","map":{"version":3,"sources":["/Users/rajabu/.config/yarn/global/node_modules/@dhis2/app-service-data/build/es/links/RestAPILink/fetchData.js"],"names":["FetchError","parseContentType","contentType","split","trim","toLowerCase","parseStatus","response","accessError","status","message","details","json","e","type","concat","statusText","fetchData","url","options","fetch","credentials","headers","Accept","catch","err","then","get","test","text","blob"],"mappings":"AAAA,SAASA,UAAT,QAA2B,cAA3B;AACA,OAAO,MAAMC,gBAAgB,GAAGC,WAAW,IAAIA,WAAW,GAAGA,WAAW,CAACC,KAAZ,CAAkB,GAAlB,EAAuB,CAAvB,EAA0BC,IAA1B,GAAiCC,WAAjC,EAAH,GAAoD,EAAvG;AACP,OAAO,MAAMC,WAAW,GAAG,MAAMC,QAAN,IAAkB;AAC3C,QAAMC,WAAW,GAAGD,QAAQ,CAACE,MAAT,KAAoB,GAApB,IAA2BF,QAAQ,CAACE,MAAT,KAAoB,GAA/C,IAAsDF,QAAQ,CAACE,MAAT,KAAoB,GAA9F;;AAEA,MAAID,WAAJ,EAAiB;AACf,QAAIE,OAAJ;AACA,QAAIC,OAAO,GAAG,EAAd;;AAEA,QAAI;AACFA,MAAAA,OAAO,GAAG,MAAMJ,QAAQ,CAACK,IAAT,EAAhB;AACAF,MAAAA,OAAO,GAAGC,OAAO,CAACD,OAAlB;AACD,KAHD,CAGE,OAAOG,CAAP,EAAU,CAAC;AACZ,KARc,CAQb;;;AAGF,QAAI,CAACH,OAAL,EAAc;AACZA,MAAAA,OAAO,GAAGH,QAAQ,CAACE,MAAT,KAAoB,GAApB,GAA0B,cAA1B,GAA2C,WAArD;AACD;;AAED,UAAM,IAAIT,UAAJ,CAAe;AACnBc,MAAAA,IAAI,EAAE,QADa;AAEnBJ,MAAAA,OAFmB;AAGnBC,MAAAA;AAHmB,KAAf,CAAN;AAKD;;AAED,MAAIJ,QAAQ,CAACE,MAAT,GAAkB,GAAlB,IAAyBF,QAAQ,CAACE,MAAT,IAAmB,GAAhD,EAAqD;AACnD,UAAMC,OAAO,GAAG,+BAA+BK,MAA/B,CAAsCR,QAAQ,CAACS,UAA/C,EAA2D,IAA3D,EAAiED,MAAjE,CAAwER,QAAQ,CAACE,MAAjF,EAAyF,GAAzF,CAAhB;AACA,QAAIE,OAAO,GAAG,EAAd;;AAEA,QAAI;AACFA,MAAAA,OAAO,GAAG,MAAMJ,QAAQ,CAACK,IAAT,EAAhB;AACD,KAFD,CAEE,OAAOC,CAAP,EAAU,CAAC;AACZ;;AAED,UAAM,IAAIb,UAAJ,CAAe;AACnBc,MAAAA,IAAI,EAAE,SADa;AAEnBJ,MAAAA,OAFmB;AAGnBC,MAAAA;AAHmB,KAAf,CAAN;AAKD;;AAED,SAAOJ,QAAP;AACD,CA1CM;AA2CP,OAAO,SAASU,SAAT,CAAmBC,GAAnB,EAAwBC,OAAO,GAAG,EAAlC,EAAsC;AAC3C,SAAOC,KAAK,CAACF,GAAD,EAAM,EAAE,GAAGC,OAAL;AAChBE,IAAAA,WAAW,EAAE,SADG;AAEhBC,IAAAA,OAAO,EAAE;AACP,0BAAoB,gBADb;AAEPC,MAAAA,MAAM,EAAE,kBAFD;AAGP,SAAGJ,OAAO,CAACG;AAHJ;AAFO,GAAN,CAAL,CAOJE,KAPI,CAOEC,GAAG,IAAI;AACd,UAAM,IAAIzB,UAAJ,CAAe;AACnBc,MAAAA,IAAI,EAAE,SADa;AAEnBJ,MAAAA,OAAO,EAAE,mCAFU;AAGnBC,MAAAA,OAAO,EAAEc;AAHU,KAAf,CAAN;AAKD,GAbM,EAaJC,IAbI,CAaCpB,WAbD,EAacoB,IAbd,CAamB,MAAMnB,QAAN,IAAkB;AAC1C,UAAML,WAAW,GAAGD,gBAAgB,CAACM,QAAQ,CAACe,OAAT,CAAiBK,GAAjB,CAAqB,cAArB,CAAD,CAApC,CAD0C,CACkC;;AAE5E,QAAIzB,WAAW,KAAK,kBAApB,EAAwC;AACtC,aAAO,MAAMK,QAAQ,CAACK,IAAT,EAAb,CADsC,CACR;AAC/B,KALyC,CAKxC;;;AAGF,QAAI,sBAAsBgB,IAAtB,CAA2B1B,WAA3B,CAAJ,EAA6C;AAC3C,aAAO,MAAMK,QAAQ,CAACsB,IAAT,EAAb;AACD;;AAED,WAAO,MAAMtB,QAAQ,CAACuB,IAAT,EAAb;AACD,GA1BM,CAAP;AA2BD","sourcesContent":["import { FetchError } from '../../engine';\nexport const parseContentType = contentType => contentType ? contentType.split(';')[0].trim().toLowerCase() : '';\nexport const parseStatus = async response => {\n  const accessError = response.status === 401 || response.status === 403 || response.status === 409;\n\n  if (accessError) {\n    let message;\n    let details = {};\n\n    try {\n      details = await response.json();\n      message = details.message;\n    } catch (e) {// Do nothing\n    } // Set a message in case of invalid json, or json without 'message' property\n\n\n    if (!message) {\n      message = response.status === 401 ? 'Unauthorized' : 'Forbidden';\n    }\n\n    throw new FetchError({\n      type: 'access',\n      message,\n      details\n    });\n  }\n\n  if (response.status < 200 || response.status >= 400) {\n    const message = \"An unknown error occurred - \".concat(response.statusText, \" (\").concat(response.status, \")\");\n    let details = {};\n\n    try {\n      details = await response.json();\n    } catch (e) {// We can leave details as is if parsing fails\n    }\n\n    throw new FetchError({\n      type: 'unknown',\n      message,\n      details\n    });\n  }\n\n  return response;\n};\nexport function fetchData(url, options = {}) {\n  return fetch(url, { ...options,\n    credentials: 'include',\n    headers: {\n      'X-Requested-With': 'XMLHttpRequest',\n      Accept: 'application/json',\n      ...options.headers\n    }\n  }).catch(err => {\n    throw new FetchError({\n      type: 'network',\n      message: 'An unknown network error occurred',\n      details: err\n    });\n  }).then(parseStatus).then(async response => {\n    const contentType = parseContentType(response.headers.get('Content-Type')); // 'application/json'\n\n    if (contentType === 'application/json') {\n      return await response.json(); // Will throw if invalid JSON!\n    } // 'text/*'\n\n\n    if (/^text\\/[a-z0-9.-]+$/.test(contentType)) {\n      return await response.text();\n    }\n\n    return await response.blob();\n  });\n}"]},"metadata":{},"sourceType":"module"}