{"ast":null,"code":"import _JSXStyle from \"styled-jsx/style\";\nimport PropTypes from 'prop-types';\nimport React, { useEffect, useRef } from 'react';\n''; // TODO: https://github.com/jsdoc/jsdoc/issues/1718\n\n/**\n * @module\n *\n * @param {IntersectionDetector.PropTypes} props\n * @returns {React.Component}\n */\n\nexport const IntersectionDetector = ({\n  threshold,\n  onChange,\n  children,\n  className,\n  dataTest,\n  rootRef\n}) => {\n  // Use useRef instead of useState to prevent unnecessary re-render:\n  //   The state changes won't be reflected in what this component renders,\n  //   so there's no need for re-rendering the (potentially computational\n  //   heavy) children.  Also: If the parent re-renders (e. g. due to a state\n  //   change), then this component will re-render as well.\n  // @var {Object}\n  // @prop {bool} current\n  const isIntersecting = useRef(); // @var {Object}\n  // @prop {HTMLElement} current\n\n  const intersectionRef = useRef();\n  useEffect(() => {\n    const rootEl = rootRef.current;\n    const intersectionEl = intersectionRef.current;\n\n    if (rootEl && intersectionEl) {\n      const onIntersection = entries => {\n        // Currently there's no way to supply multiple thresholds,\n        // so a single entry can be assumed safely\n        const [entry] = entries; // Make sure the callback is not called multiple times\n        // if there is no change\n\n        const intersectionChange = entry.isIntersecting !== isIntersecting.current;\n\n        if (intersectionChange) {\n          isIntersecting.current = entry.isIntersecting;\n          onChange({\n            isIntersecting: entry.isIntersecting\n          });\n        }\n      };\n\n      const observerOptions = {\n        root: rootEl,\n        threshold\n      };\n      const intersectionObserver = new IntersectionObserver(onIntersection, observerOptions);\n      intersectionObserver.observe(intersectionEl); // Make sure to clean up everything when un-mounting.\n      // Using an arrow function instead of just returning\n      // the disconnect function for better readability.\n\n      return () => intersectionObserver.disconnect();\n    }\n  }, [rootRef.current, intersectionRef.current]);\n  return /*#__PURE__*/React.createElement(\"div\", {\n    ref: intersectionRef,\n    \"data-test\": dataTest,\n    className: \"jsx-2829611397\" + \" \" + (className || \"\")\n  }, children, /*#__PURE__*/React.createElement(_JSXStyle, {\n    id: \"2829611397\"\n  }, [\"div.jsx-2829611397{height:100%;}\"]));\n};\nIntersectionDetector.defaultProps = {\n  threshold: 0,\n  dataTest: 'dhis2-uicore-intersectiondetector'\n};\n/**\n * @typedef {Object} PropTypes\n * @static\n *\n * @prop {Object} rootRef React ref on other component to detect intersections with\n * @prop {HTMLElement} [rootRef.current]\n * @prop {Function} onChange Called with signature `({ isIntersecting: bool })`\n * @prop {any} [children]\n * @prop {string} [className]\n * @prop {number} [threshold] The [threshold](https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API#Intersection_observer_options) value: a value from 0.0 to 1.0 that controls the point at which an intersecting component is considered 'intersected' or 'visible' and the onChange callback triggers\n */\n\nIntersectionDetector.propTypes = {\n  /** React ref on other component to detect intersections with */\n  rootRef: PropTypes.shape({\n    // not required so `current` can be `null`\n    current: PropTypes.instanceOf(HTMLElement)\n  }).isRequired,\n\n  /** Called with signature `({ isIntersecting: bool })` */\n  onChange: PropTypes.func.isRequired,\n  children: PropTypes.any,\n  className: PropTypes.string,\n  dataTest: PropTypes.string,\n\n  /** The [threshold](https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API#Intersection_observer_options) value: a value from 0.0 to 1.0 that controls the point at which an intersecting component is considered 'intersected' or 'visible' and the onChange callback triggers */\n  threshold: PropTypes.number\n};","map":{"version":3,"sources":["/Users/rajabu/.config/yarn/global/node_modules/@dhis2/ui/node_modules/@dhis2/ui-core/build/es/IntersectionDetector/IntersectionDetector.js"],"names":["_JSXStyle","PropTypes","React","useEffect","useRef","IntersectionDetector","threshold","onChange","children","className","dataTest","rootRef","isIntersecting","intersectionRef","rootEl","current","intersectionEl","onIntersection","entries","entry","intersectionChange","observerOptions","root","intersectionObserver","IntersectionObserver","observe","disconnect","createElement","ref","id","defaultProps","propTypes","shape","instanceOf","HTMLElement","isRequired","func","any","string","number"],"mappings":"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","sourcesContent":["import _JSXStyle from \"styled-jsx/style\";\nimport PropTypes from 'prop-types';\nimport React, { useEffect, useRef } from 'react';\n''; // TODO: https://github.com/jsdoc/jsdoc/issues/1718\n\n/**\n * @module\n *\n * @param {IntersectionDetector.PropTypes} props\n * @returns {React.Component}\n */\n\nexport const IntersectionDetector = ({\n  threshold,\n  onChange,\n  children,\n  className,\n  dataTest,\n  rootRef\n}) => {\n  // Use useRef instead of useState to prevent unnecessary re-render:\n  //   The state changes won't be reflected in what this component renders,\n  //   so there's no need for re-rendering the (potentially computational\n  //   heavy) children.  Also: If the parent re-renders (e. g. due to a state\n  //   change), then this component will re-render as well.\n  // @var {Object}\n  // @prop {bool} current\n  const isIntersecting = useRef(); // @var {Object}\n  // @prop {HTMLElement} current\n\n  const intersectionRef = useRef();\n  useEffect(() => {\n    const rootEl = rootRef.current;\n    const intersectionEl = intersectionRef.current;\n\n    if (rootEl && intersectionEl) {\n      const onIntersection = entries => {\n        // Currently there's no way to supply multiple thresholds,\n        // so a single entry can be assumed safely\n        const [entry] = entries; // Make sure the callback is not called multiple times\n        // if there is no change\n\n        const intersectionChange = entry.isIntersecting !== isIntersecting.current;\n\n        if (intersectionChange) {\n          isIntersecting.current = entry.isIntersecting;\n          onChange({\n            isIntersecting: entry.isIntersecting\n          });\n        }\n      };\n\n      const observerOptions = {\n        root: rootEl,\n        threshold\n      };\n      const intersectionObserver = new IntersectionObserver(onIntersection, observerOptions);\n      intersectionObserver.observe(intersectionEl); // Make sure to clean up everything when un-mounting.\n      // Using an arrow function instead of just returning\n      // the disconnect function for better readability.\n\n      return () => intersectionObserver.disconnect();\n    }\n  }, [rootRef.current, intersectionRef.current]);\n  return /*#__PURE__*/React.createElement(\"div\", {\n    ref: intersectionRef,\n    \"data-test\": dataTest,\n    className: \"jsx-2829611397\" + \" \" + (className || \"\")\n  }, children, /*#__PURE__*/React.createElement(_JSXStyle, {\n    id: \"2829611397\"\n  }, [\"div.jsx-2829611397{height:100%;}\"]));\n};\nIntersectionDetector.defaultProps = {\n  threshold: 0,\n  dataTest: 'dhis2-uicore-intersectiondetector'\n};\n/**\n * @typedef {Object} PropTypes\n * @static\n *\n * @prop {Object} rootRef React ref on other component to detect intersections with\n * @prop {HTMLElement} [rootRef.current]\n * @prop {Function} onChange Called with signature `({ isIntersecting: bool })`\n * @prop {any} [children]\n * @prop {string} [className]\n * @prop {number} [threshold] The [threshold](https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API#Intersection_observer_options) value: a value from 0.0 to 1.0 that controls the point at which an intersecting component is considered 'intersected' or 'visible' and the onChange callback triggers\n */\n\nIntersectionDetector.propTypes = {\n  /** React ref on other component to detect intersections with */\n  rootRef: PropTypes.shape({\n    // not required so `current` can be `null`\n    current: PropTypes.instanceOf(HTMLElement)\n  }).isRequired,\n\n  /** Called with signature `({ isIntersecting: bool })` */\n  onChange: PropTypes.func.isRequired,\n  children: PropTypes.any,\n  className: PropTypes.string,\n  dataTest: PropTypes.string,\n\n  /** The [threshold](https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API#Intersection_observer_options) value: a value from 0.0 to 1.0 that controls the point at which an intersecting component is considered 'intersected' or 'visible' and the onChange callback triggers */\n  threshold: PropTypes.number\n};"]},"metadata":{},"sourceType":"module"}