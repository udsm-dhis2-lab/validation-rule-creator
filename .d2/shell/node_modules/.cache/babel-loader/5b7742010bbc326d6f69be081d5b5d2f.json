{"ast":null,"code":"import { useState, useCallback, useRef, useEffect } from 'react';\nimport { FetchError } from '../../engine';\nimport { useStaticInput } from './useStaticInput';\nexport const useQueryExecutor = ({\n  execute,\n  variables: initialVariables,\n  singular,\n  immediate,\n  onComplete,\n  onError\n}) => {\n  const [theExecute] = useStaticInput(execute);\n  const [state, setState] = useState({\n    called: !!immediate,\n    loading: !!immediate\n  });\n  const variables = useRef(initialVariables);\n  const abortControllersRef = useRef([]);\n  const abort = useCallback(() => {\n    abortControllersRef.current.forEach(controller => controller.abort());\n    abortControllersRef.current = [];\n  }, []);\n  const manualAbort = useCallback(() => {\n    abort();\n    setState(state => ({\n      called: state.called,\n      loading: false,\n      error: new FetchError({\n        type: 'aborted',\n        message: 'Aborted'\n      })\n    }));\n  }, [abort]);\n  const refetch = useCallback((newVariables = {}) => {\n    setState(state => !state.called || !state.loading ? {\n      called: true,\n      loading: true\n    } : state);\n\n    if (singular) {\n      abort(); // Cleanup any in-progress fetches\n    }\n\n    const controller = new AbortController();\n    abortControllersRef.current.push(controller);\n    variables.current = { ...variables.current,\n      ...newVariables\n    };\n    const options = {\n      variables: variables.current,\n      signal: controller.signal,\n      onComplete,\n      onError\n    };\n    return theExecute(options).then(data => {\n      if (!controller.signal.aborted) {\n        setState({\n          called: true,\n          loading: false,\n          data\n        });\n        return data;\n      }\n\n      return new Promise(() => undefined); // Wait forever\n    }).catch(error => {\n      if (!controller.signal.aborted) {\n        setState({\n          called: true,\n          loading: false,\n          error\n        });\n      }\n\n      return new Promise(() => undefined); // Don't throw errors in refetch promises, wait forever\n    });\n  }, [abort, onComplete, onError, singular, theExecute]); // Don't include immediate or refetch as deps, otherwise unintentional refetches\n  // may be triggered by changes to input, i.e. recreating the onComplete callback\n\n  useEffect(() => {\n    if (immediate) {\n      refetch();\n    }\n\n    return abort;\n  }, []); // eslint-disable-line react-hooks/exhaustive-deps\n\n  return {\n    refetch,\n    abort: manualAbort,\n    ...state\n  };\n};","map":{"version":3,"sources":["/Users/rajabu/.config/yarn/global/node_modules/@dhis2/app-service-data/build/es/react/hooks/useQueryExecutor.js"],"names":["useState","useCallback","useRef","useEffect","FetchError","useStaticInput","useQueryExecutor","execute","variables","initialVariables","singular","immediate","onComplete","onError","theExecute","state","setState","called","loading","abortControllersRef","abort","current","forEach","controller","manualAbort","error","type","message","refetch","newVariables","AbortController","push","options","signal","then","data","aborted","Promise","undefined","catch"],"mappings":"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","sourcesContent":["import { useState, useCallback, useRef, useEffect } from 'react';\nimport { FetchError } from '../../engine';\nimport { useStaticInput } from './useStaticInput';\nexport const useQueryExecutor = ({\n  execute,\n  variables: initialVariables,\n  singular,\n  immediate,\n  onComplete,\n  onError\n}) => {\n  const [theExecute] = useStaticInput(execute);\n  const [state, setState] = useState({\n    called: !!immediate,\n    loading: !!immediate\n  });\n  const variables = useRef(initialVariables);\n  const abortControllersRef = useRef([]);\n  const abort = useCallback(() => {\n    abortControllersRef.current.forEach(controller => controller.abort());\n    abortControllersRef.current = [];\n  }, []);\n  const manualAbort = useCallback(() => {\n    abort();\n    setState(state => ({\n      called: state.called,\n      loading: false,\n      error: new FetchError({\n        type: 'aborted',\n        message: 'Aborted'\n      })\n    }));\n  }, [abort]);\n  const refetch = useCallback((newVariables = {}) => {\n    setState(state => !state.called || !state.loading ? {\n      called: true,\n      loading: true\n    } : state);\n\n    if (singular) {\n      abort(); // Cleanup any in-progress fetches\n    }\n\n    const controller = new AbortController();\n    abortControllersRef.current.push(controller);\n    variables.current = { ...variables.current,\n      ...newVariables\n    };\n    const options = {\n      variables: variables.current,\n      signal: controller.signal,\n      onComplete,\n      onError\n    };\n    return theExecute(options).then(data => {\n      if (!controller.signal.aborted) {\n        setState({\n          called: true,\n          loading: false,\n          data\n        });\n        return data;\n      }\n\n      return new Promise(() => undefined); // Wait forever\n    }).catch(error => {\n      if (!controller.signal.aborted) {\n        setState({\n          called: true,\n          loading: false,\n          error\n        });\n      }\n\n      return new Promise(() => undefined); // Don't throw errors in refetch promises, wait forever\n    });\n  }, [abort, onComplete, onError, singular, theExecute]); // Don't include immediate or refetch as deps, otherwise unintentional refetches\n  // may be triggered by changes to input, i.e. recreating the onComplete callback\n\n  useEffect(() => {\n    if (immediate) {\n      refetch();\n    }\n\n    return abort;\n  }, []); // eslint-disable-line react-hooks/exhaustive-deps\n\n  return {\n    refetch,\n    abort: manualAbort,\n    ...state\n  };\n};"]},"metadata":{},"sourceType":"module"}